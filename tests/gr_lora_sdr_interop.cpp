#include <lora_phy/phy.hpp>
#include <cstdint>
#include <vector>
#include <complex>
#include <fstream>
#include <cstring>

static bool read_iq_file(const char* path, std::vector<std::complex<float>>& out) {
    std::ifstream f(path, std::ios::binary);
    if (!f) return false;
    while (true) {
        float re, im;
        f.read(reinterpret_cast<char*>(&re), sizeof(float));
        f.read(reinterpret_cast<char*>(&im), sizeof(float));
        if (!f) break;
        out.emplace_back(re, im);
    }
    return !out.empty();
}

int gr_lora_sdr_interop_main() {
    const char* paths[] = {"test_output.iq", "../test_output.iq"};
    std::vector<std::complex<float>> ref_samples;
    bool loaded = false;
    for (const char* p : paths) {
        if (read_iq_file(p, ref_samples)) { loaded = true; break; }
    }
    if (!loaded) return 1; // unable to load reference IQ

    // Known payload generated by gr-lora_sdr for this fixture
    const std::vector<uint8_t> payload = {0xBE, 0xE7, 0x82, 0x75, 0xE0};
    const uint8_t expected_sync = 0x29; // sync word used by reference
    const unsigned sf = 7;
    const unsigned osr = 2; // oversampling factor in the fixture

    // Demodulate reference samples and verify sync + payload
    lora_phy::lora_demod_workspace ws{};
    std::vector<std::complex<float>> scratch(ref_samples.size());
    std::vector<uint16_t> demod_symbols(ref_samples.size() / ((1u << sf) * osr));
    lora_phy::lora_demod_init(&ws, sf, lora_phy::window_type::window_none,
                              scratch.data(), scratch.size());
    uint8_t out_sync = 0;
    size_t produced = lora_phy::lora_demodulate(&ws, ref_samples.data(),
                                                ref_samples.size(), demod_symbols.data(),
                                                osr, &out_sync);
    lora_phy::lora_demod_free(&ws);

    std::vector<uint8_t> decoded(payload.size());
    lora_phy::lora_decode(demod_symbols.data(), produced, decoded.data());

    bool ok = (out_sync == expected_sync) && (decoded == payload);
    return ok ? 0 : 1;
}

